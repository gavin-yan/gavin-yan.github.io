<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Java虚拟机]]></title>
    <url>%2F2019%2F07%2F07%2FJavaVirtualMachine%2F</url>
    <content type="text"><![CDATA[一、自动内存管理机制1. 运行时数据区域Java虚拟机在执行Java程序的过程中会把它所管理的内存划分为如下的数据区域： (1) 程序计数器（Program Counter Register）或者叫PC寄存器 每个线程都有独立的程序计数器，是线程私有的 如果线程正在执行的是Java方法，则该区域保存的是虚拟机正在执行的字节码指令的地址 如果线程正在执行的是Native方法，则该区域值为空（Undefined） 该区域没有规定发生OutOfMemoryError异常的情况 (2) Java虚拟机栈（Java Virtual Machine stack） 每个线程都有自己的Java虚拟机栈，是线程私有的，生命周期与线程相同 存储栈帧，每个Java方法执行时都会创建栈帧，每个方法调用到完成的过程对应着一个栈帧在虚拟机栈中入栈到出栈的过程 虚拟机栈的容量可以实现成固定大小，也可以实现成可动态收缩和扩展，栈所使用的内存不需要是连续的 该区域包含两种异常状况： 如果线程请求的栈容量超过Java虚拟机栈允许的最大容量，Java虚拟机会抛出StackOverflowError异常 如果Java虚拟机栈动态扩展时无法申请到足够的内存或者创建新的线程时没有足够的内存创建对应的虚拟机栈，Java虚拟机会抛出OutOfMemoryError异常 栈帧在一个活动线程中，只有目前正在执行的方法的栈帧是活动的，称为当前栈帧，栈帧对应的方法称为当前方法，定义这个方法的类称为当前类。栈帧包括以下组成部分： 局部变量表 表的大小在编译期决定，写进方法表的Code属性之中，最小单位称为变量槽，即Slot 局部变量表用于存放方法参数及方法内部定义的局部变量 一个Slot可以保存一个类型为boolean、byte、char、short、int、float、reference或returnAddress的数据，两个连续Slot可以保存一个类型为long或double的数据 局部变量表使用索引来定位，起始值为0，是整数 调用类方法时，方法参数及局部变量会依次传递到局部变量表中从0开始的连续位置上，调用实例方法时，第0个Slot存储的一定是实例方法所在对象的引用reference，后续参数从1开始存储 操作数栈 是一个后进先出栈，栈的大小在编译器决定，写进方法表的Code属性之中 操作数栈存放的是从局部变量表或对象实例的字段中复制的常量或变量，用于进行加法之类字节码指令的运算 操作数栈的每一个元素可以是任意Java数据类型，32位及以内数据类型所占栈容量为1，64位数据类型所占栈容量为2 动态链接 每个栈帧包含了一个指向当前栈帧所在方法的运行时常量池的引用，以便实现动态链接 方法返回地址 一个方法调用完成包括两种退出方式 正常完成出口：方法执行过程中没有抛出任何异常，此时可能会有返回值传递给上层的方法调用者 异常完成出口：方法执行过程中抛出异常且在该方法中没有处理该异常，此时不会有任何返回值 方法返回时，需要保存一些信息用于帮助恢复它的上层方法的执行状态 正常完成出口：调用者的程序计数器的值作为返回地址，栈帧中会保存该信息 异常完成出口：返回地址通过异常处理表来确定，栈帧中不保存该信息 方法退出时的操作：恢复上层方法的局部变量表和操作数栈，把返回值（如果有）压入调用者栈帧的操作数栈，调整程序计数器的值以指向方法调用指令后面的一条指令 附加信息 具体的虚拟机实现可以增加一些额外信息到栈帧中，例如与调试相关的信息，与具体的虚拟机实现相关 (3) 本地方法栈（Native Method Stack） 与Java虚拟机栈类似，不同的是Java虚拟机栈是为Java方法服务，本地方法栈是为Native方法服务 本地方法栈的容量可以实现成固定大小，也可以实现成可动态收缩和扩展 异常状况与Java虚拟机栈完全一致，包括StackOverflowError异常和OutOfMemoryError异常 (4) Java堆 是所有线程共享的内存区域，在虚拟机启动时被创建 存储所有类实例和数组对象分配的内存，是垃圾收集器管理的主要区域 堆的容量可以实现成固定大小，也可以实现成可动态收缩和扩展，堆所使用的内存不需要是连续的 该区域包含一种异常状况：如果Java堆容量不能满足内存分配请求且无法扩展时，Java虚拟机会抛出OutOfMemoryError异常· (5) 方法区（永久代，元空间） 是所有线程共享的内存区域，在虚拟机启动时被创建 存储已被虚拟机加载的类信息、运行时常量池、静态变量、即时编译器编译后的数据 方法区的容量可以实现成固定大小，也可以实现成可动态收缩和扩展，方法区所使用的内存不需要是连续的，该区域可以不实现垃圾收集和压缩 该区域包含一种异常状况：如果方法区容量不能满足内存分配请求且无法扩展时，Java虚拟机会抛出OutOfMemoryError异常 方法区是一个JVM规范，永久代和元空间是其一种实现方式。JDK1.7及之前，HotSpot虚拟机使用永久代来实现方法区；JDK1.8及以后移除了永久代，原来永久代的数据被分到了堆和元空间（本地内存，非虚拟机内存）中，堆存储运行时常量池和静态变量，元空间存储类信息。 2. 对象存活策略(1) 判断对象是否存活 引用计数算法 思想：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值加1，当引用失效时，计数器值减1，任何时刻计数器为0的对象就是不可能再被使用的 缺点：很难解决对象之间相互循环引用的问题 可达性分析算法（Java虚拟机采用的算法） 思想：通过一系列称为“GC Roots”的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链，当一个对象到GCRoots没有任何引用链相连时，则证明此对象是不可用的 在Java语言中，可作为GC Roots的对象包括： Java虚拟机栈（栈帧中的局部变量表）中引用的对象 本地方法栈中JNI（即一般说的Native方法）引用的对象 方法区中类静态属性引用的对象 方法区中常量引用的对象 (2) 引用分类（强度依次减弱） 强引用（Strong Reference） 类似“Object obj = new Object()”的引用 只要强引用还在，垃圾收集器就不会回收掉被引用的对象 软引用（Soft Reference） 用于描述一些还有用但并非必需的对象 对于软引用关联的对象，当将要发生内存溢出异常之前，将会把这些对象列进回收范围之内进行第二次回收 SoftReference类用于实现软引用123Object obj = new Object();SoftReference&lt;Object&gt; sf = new SoftReference&lt;Object&gt;(obj);obj = null; // 使对象只被软引用关联 弱引用（Weak Reference） 同样用于描述非必需对象，被弱引用关联的对象只能生存到下一次垃圾收集发生之前 当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象 WeakReference类用于实现弱引用123Object obj = new Object();WeakReference&lt;Object&gt; wf = new WeakReference&lt;Object&gt;(obj);obj = null; // 使对象只被弱引用关联 虚引用（Phantom Reference） 一个对象是否有虚引用，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例 为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知 PhantomReference类用于实现虚引用123Object obj = new Object();PhantomReference&lt;Object&gt; pf = new PhantomReference&lt;Object&gt;(obj, null);obj = null; // 使对象只被虚引用关联 (3) 对象是否真的被回收 如果对象在进行可达性分析后发现没有与GC Roots相连接的引用链，那它会进行第一次标记并且进行一次筛选，筛选的条件是此对象是否有必要执行finalize方法 当对象没有覆盖finalize()方法，或者finalize()方法已经被虚拟机调用过，则“没有必要执行”finalize方法 如果对象被判定为有必要执行finalize()方法，则该对象将被放置在一个F-Queue队列之中，并且稍后由一个虚拟机自动建立的、低优先级的Finalizer线程会去触发finalize()方法，但并不承诺会等待它运行结束 稍后GC将对F-Queue中的对象进行第二次小规模的标记，如果对象在finalize()方法中重新与引用链上的任何一个对象建立关联，则第二次标记时将被移除出“即将回收”的队列，否则的话它将真的被回收 需要注意的是，任何对象的finalize()方法都只会被系统自动调用一次 (4) 方法区（永久代、元空间）常量与类是否存活 方法区的垃圾收集主要是废弃常量和无用的类 判断一个常量是否是废弃常量 如果没有任何对象引用常量池中的某一个常量，则该常量就是废弃常量 判断一个类是否是无用的类（全部满足） 该类所有的实例都已经被回收，即Java堆中不存在该类的任何实例 加载该类的ClassLoader已经被回收 该类对应的java.lang.Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 (5) HotSpot虚拟机的可达性分析算法实现 枚举根节点 需要进行GC停顿，即必须停顿所有Java执行线程，确保引用关系不会变化 虚拟机利用OopMap数据结构得知哪些地方存放着对象引用 安全点 由于为每条指令都生成OopMap会需要大量的额外空间，因此虚拟机只在特定的位置记录了这些信息，这些位置称为安全点，即程序执行时并非在所有地方都能停顿下来开始GC，而是只有在到达安全点时才能暂停 安全点的选定是以程序“是否具有让程序长时间执行的特征”为标准进行选定，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，具有这些功能的指令才会产生安全点 如何在GC发生时让所有线程都“跑”到最近的安全点再停顿下来 抢先式中断：不需要线程的执行代码主动配合，在GC发生时，首先把所有线程全部中断，如果发现有线程中断的地方不在安全点上，就恢复线程，让它“跑”到安全点上（没有虚拟机采用该方法） 主动式中断：当GC需要中断线程时，不直接对线程操作，只是设置一个标志，各个线程执行时主动去轮询该标志，发现中断标志为真时就自己中断挂起。轮询标志的地方与安全点是重合的，另外还包括创建对象需要分配内存的地方。 安全区域 当线程不执行时，处于Sleep状态或者Blocked状态时，无法响应中断请求，走到安全的地方把自己挂起来，该种情形就需要安全区域来解决 安全区域是指在一段代码片段之中，引用关系不会发生变化，在这个区域中的任意地方开始GC都是安全的 在线程执行到安全区域中的代码时，首先标识自己已经进入了安全区域，这样在这段时间里虚拟机要发起GC时，就不需要管标识自己为安全区域状态的线程了。在线程要离开安全区域时，它要检查系统是否已经完成了根节点枚举或是整个GC过程，如果完成了，线程就继续执行，否则它就必须等待直到收到可以安全离开安全区域的信号为止 3. 垃圾收集策略(1) 垃圾收集算法 标记-清除算法 最基础的收集算法 算法分为“标记”和“清除”两个阶段： 首先标记出所有需要回收的对象，标记的方法见“对象存活策略” 在标记完成后统一回收所有被标记的对象 缺点： 效率问题：标记和清除两个过程效率都不高 空间问题：标记清除之后会产生大量不连续的内存碎片，空间碎片太多会导致以后需要分配较大对象时，无法找到足够的连续内存而不得不提前触发另一次垃圾收集动作 复制算法 将可用内存按容量划分为大小相等的两块，每次只使用其中的一块。当这一块的内存用完了，就将还存活着的对象复制到另外一块上面，然后再把已使用过的内存空间一次清理掉 优点：每次都是对整个半区进行内存回收，内存分配时不用考虑内存碎片等复杂情况，只要移动堆顶指针，按顺序分配内存即可，实现简单，运行高效 缺点： 算法代价较高，将可用内存缩小为了原来的一半 对象存活率较高时，需要进行较多的复制操作，效率会变低 现在的商业虚拟机都采用该收集算法来回收新生代，由于新生代中的对象98%是“朝生夕死”的，因此不需要按照1:1来分配内存，而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor空间。 当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。 当Survivor空间不够用时，需要依赖其他内存（这里指老年代）进行分配担保。 标记-整理算法 标记过程与“标记-清除”算法一样 但是在对可回收对象进行清理时，让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存 优点：不会产生内存碎片 缺点：需要移动大量对象，效率比较低 适用于老年代对象 分代收集算法 当前商业虚拟机的垃圾收集都采用该算法 并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块： 新生代：对象存活率低，选用复制算法 老年代：对象存活率高，选用“标记-清除”或“标记-整理”算法 (2) HotSpot虚拟机垃圾收集器 Serial收集器（新生代、单线程、复制算法） 虚拟机运行在Client模式下的默认新生代收集器 单线程收集器：不仅仅说明它只会使用一个CPU或一条收集线程去完成垃圾收集工作，更重要的是，在它进行垃圾收集时，必须暂停其他所有的工作线程，直到收集结束 优点是简单而高效（与其他收集器的单线程相比），没有线程交互的开销 ParNew收集器（新生代、多线程、标记-整理算法） Serial收集器的多线程版本：多条线程去完成垃圾收集工作，用户工作线程依然暂停 虚拟机运行在Server模式下的首选新生代收集器，除Serial收集器外唯一能与CMS收集器配合工作的收集器 Parallel Scavenge收集器（新生代、多线程、标记-整理算法） 比起缩短垃圾收集的用户线程停顿时间，更加关注吞吐量，吞吐量 = 运行用户代码时间 / （运行用户代码时间 + 垃圾收集时间），停顿时间短适合需要与用户交互的程序，高吞吐量则可以高效地利用CPU时间，尽快完成程序的运算任务，适合在后台运算的任务 该收集器提供了两个参数用于精确控制吞吐量，一个是控制最大垃圾收集停顿时间，一个是设置吞吐量大小 拥有GC自适应的调节策略，开启一个开关参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整新生代大小、Eden与Survivor区的比例、晋升老年代对象年龄等参数以提供最合适的停顿时间或者最大吞吐量 Serial Old 收集器（老年代、单线程、复制算法） Serial收集器的老年代版本，单线程收集器 主要在Client模式下的虚拟机使用 如果在Server模式下，则一方面在JDK1.5及之前与Parallel Scavenge收集器配合使用，另一种则作为CMS收集器的后备预案 Parallel Old收集器（老年代、多线程、标记-整理算法） Parallel Scavenge收集器的老年代版本，多线程收集器 JDK1.6版本开始提供，用于和Parallel Scavenge收集器进行配合，因为Serial Old收集器是单线程的，无法充分利用多CPU的处理能力 CMS（Concurrent Mark Sweep）收集器（老年代、并发、标记-清除算法） 一种以获取最短回收停顿时间为目标的收集器，适用于B/S系统的服务端上 第一款真正意义上的并发收集器（垃圾收集线程与用户线程同时工作） 与其他老年代收集器不同，采用标记-清除算法，整个过程分为4个步骤： 初始标记：需要GC停顿，只是标记一下GC Roots能 “直接” 关联到的对象 并发标记：进行GC Roots Tracing的过程，不需要停顿 重新标记：需要GC停顿，为了修正并发标记期间因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录 并发清除：不需要停顿 有3个明显的缺点： 对CPU资源非常敏感：如果CPU资源较少，垃圾收集会因为占用了一部分线程而导致应用程序变慢，总吞吐量降低 无法处理浮动垃圾：由于和用户线程是并行的，在标记过程之后，还会有垃圾产生，留待下次GC时清理，这就是浮动垃圾。另一方面，还需要预留一部分内存空间给用户线程，不能等老年代快满了再进行收集，如果预留内存不够，就会出现“Concurrent Mode Failure”失败，虚拟机会启动后备预案，临时启用Serial Old收集器来重新进行老年代的垃圾收集 基于标记-清除算法实现，收集结束时会产生大量内存空间碎片，如果没有足够空间来分配对象时会提前触发Full GC，解决方法是在CMS收集器顶不住要进行Full GC时开启内存碎片的合并整理过程 G1（Garbage-First）收集器（多线程、并发、复制算法、标记整理算法） 当前收集器技术发展的最前沿成果 面向服务端应用的垃圾收集器，目标是替换CMS服务器 具备以下特点： 并行与并发：多线程且可以和用户线程一起工作 分代收集：依然保留了分代概念，虽然可以不与其他收集器配合就独立管理整个GC堆，但是采用不同的方式管理新对象和旧对象。使用G1收集器时，Java堆的内存布局与其他收集器有很大差别，它将整个Java堆划分为多个大小相等的独立区域（Region），虽然还保留新生代和老年代的概念，但不再是物理隔离的了，它们都是一部分Region的集合 空间整合：从整体来看是基于“标记-整理”算法的，从局部（两个Region）来看是基于“复制”算法的。G1运行期间不会产生内存碎片 可预测的停顿：除了追求低停顿外，还能建立可预测的停顿时间模型，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒。之所以能实现，是因为它可以避免在整个Java堆中进行全区域的垃圾收集，G1跟踪各个Region里面的垃圾堆积的价值大小（回收所获得的空间大小以及回收所需时间的经验值），在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的Region 运作步骤 初始标记：需要GC停顿，只是标记一下GC Roots能直接关联到的对象，并且修改TAMS(Next Top at Mark Start)的值，让下一阶段用户程序并发运行时，能在正确可用的Region中创建新对象，耗时很短 并发标记：从GC Roots开始对堆中对象进行可达性分析，找出存活的对象，耗时较长，但可与用户程序并发执行 最终标记：需要GC停顿，为了修正在并发标记期间因用户程序继续运作而导致标记产生变动的那一部分标记记录，虚拟机将这段时间对象变化记录在线程Remembered Set Logs里面，最终标记阶段需要把Remembered Set Logs的数据合并到Remembered Set中 筛选回收：首先对各个Region的回收价值和成本进行排序，根据用户所期望的GC停顿时间来制定回收计划，虽然也需要GC停顿，但是因为只回收一部分Region，时间是用户可控的，并且停顿用户线程可以大幅提高收集效率 4. 内存分配策略 线程私有对象 栈上分配 线程私有小对象 无逃逸 支持标量替换 线程本地分配TLAB（Thread Local Allocation Buffer） 占用Eden，默认1% 多线程时不用竞争Eden就可以申请空间，提高效率 小对象 共享对象或线程私有空间放不下的对象优先在Eden分配 大多数情况下，对象在新生代Eden区中分配 当Eden区没有足够空间进行分配时，虚拟机将发起一次Minor GC Minor GC：指发生在新生代的垃圾收集动作，因为Java对象大多有“朝生夕死”的特性，所以Minor GC非常频繁，一般回收速度也比较快 大对象直接进入老年代 大对象是指需要大量连续内存空间的Java对象，例如很长的字符串以及数组 大于某个设置的阈值的对象将直接在老年代中分配，目的是避免在Eden区及两个Survivor区之间发生大量的内存复制（新生代采用复制算法收集内存） 长期存活的对象将进入老年代 虚拟机给每个对象定义了一个对象年龄计数器 如果对象在Eden出生并经过第一次Minor GC后仍然存活，并且能被Survivor容纳的话，将被移动到Survivor空间中，并且对象年龄设为1 对象在Survivor区中每熬过一次Minor GC，年龄就增加一岁 当对象的年龄增加到一定程度（默认15岁，可以通过参数设置），将会晋升到老年代中 动态对象年龄判定 为了适应不同程度的内存状况，虚拟机并不是永远地要求对象的年龄必须达到阈值才能晋升老年代 如果在Survivor空间中相同年龄所有对象大小的总和大于Survivor空间的一半，年龄大于或等于该年龄的对象就可以直接进入老年代 空间分配担保 在发生Minor GC之前，虚拟机会先检查老年代最大可用的连续空间是否大于新生代所有对象总空间 如果大于，那么进行Minor GC 如果小于，那么虚拟机检查是否允许担保失败 如果允许担保失败，继续检查老年代最大可用的连续空间是否大于历次晋升到老年代对象的平均大小 如果大于，进行一次有风险的Minor GC 如果小于，进行一次Full GC：指发生在老年代的GC，经常会伴随着至少一次Minor GC 如果不允许担保失败，进行一次Full GC 5. 虚拟机调优 内存设置 -Xss线程栈大小 // 如-Xss128k -Xms初始堆大小 // 如-Xms1m -Xmx最大堆大小 // 如-Xmx16m -XX:NewSize=n // 设置新生代初始大小 -XX:MaxnewSize=n // 设置新生代最大上限 -XX:NewRatio=n // 设置新生代和老年代的比值。如3代表新生代：老年代 = 1：3 -XX:SurvivorRatio=n // 设置新生代中Eden区与两个Survivor区的比值，注意Survivor有两个。如3代表Eden：两个Survivor = 3：2，即一个Survivor占新生代的1/5 -XX:PermSize=n // 设置方法区（永久代）初始大小 -XX:MaxPermSize=n // 设置方法区（永久代）最大上限 收集器设置 -XX:+UseSerialGC // 设置串行收集器 -XX:+UserParallelGC // 设置并行收集器 -XX:+UserConcMarkSweepGC // 设置并发收集器 垃圾回收统计信息 -XX:+PrintGC // 打印GC信息 -XX:+PrintGCDetails // 打印GC详细信息 -Xloggc:filename // 将日志文件输出到指定文件 典型Tomcat优化配置set JAVA_OPTS= -Xms4g -Xmx4g -Xss512k -XX:+AggressiveOpts // 能够优化的全部优化 -XX:+UserBiasedLocking // 启用偏向锁 -XX:PermSize=64m -XX:MaxPermSize=300m -XX:+DisableExplicitGC // 使显式GC（System.gc()）失效 -XX:+UseConcMarkSweepGC // 使用CMS缩短响应时间，并发收集、低停顿 -XX:+UserParNerGC // 并行收集新生代的垃圾 -XX:+CMSParallelRemarkEnabled // 在使用UseParNewGC的情况下，尽量减少mark的时间 -XX:+UseCMSCompactAtFullCollection // 使用并发收集器时，开启对老年代的压缩，使碎片减少 -XX:LargePageSizeInBytes=128m // 内存分页大小对性能的提升 -XX:+UseFastAccessorMethods // get/set方法转成本地代码 -Djava.awt.headless=true // 修复Linux下Tomcat处理图表时可能会产生的一个bug 二、虚拟机执行子系统1. Class类文件结构Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件之中，中间没有添加任何分隔符。当遇到需要占用8位字节以上空间的数据项时，则会按照高位在前（最高位字节在地址最低位，最低位字节在地址最高位）的方式分割成若干个8位字节进行存储。 Class文件格式采用一种类似于C语言结构体的伪结构来存储数据，这种伪结构只有两种数据类型：无符号数和表。 无符号数：属于基本的数据类型，以u1、u2、u4、u8来分别代表1个字节、2个字节、4个字节和8个字节的无符号数，无符号数可以用来描述数字、索引引用、数量值或者按照UTF-8编码构成字符串值 表：是由多个无符号数或者其他表作为数据项构成的复合数据类型，所有表都习惯性地以_info结尾，表用于描述有层次关系的复合结构的数据。 下面介绍具体的内容： 魔数（magic）：每个Class文件的头4个字节，唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件。魔数的值固定为0xCAFEBABE，不会改变。 副版本号（minor_version）和主版本号（major_version）：紧接着魔数的4个字节，第5和第6个字节是副版本号，第7和第8个字节是主版本号。假设某个Class文件的主版本号为M，副版本号为m，那么这个Class文件的格式版本号为M.m。高版本的JDK能向下兼容以前版本的Class文件，但不能运行以后版本的Class。 常量池：紧接着主副版本号之后 常量池计数器（constant_pool_count）：常量池表的成员数加1 常量池（constant_pool [ ]）：Class文件之中的资源仓库，是一种表结构，索引为1 ~ constant_pool_count - 1，常量池中的每一项都将第一个字节作为类型标记，常量池包括以下两大类常量： 字面量（Literal）：接近于Java语言层面的常量概念，如文本字符串、声明为final的常量 符号引用（Symbolic References）：属于编译原理方面的概念，包括类和接口的全限定名、字段的名称和描述符、方法的名称和描述符 访问标志（access_flags）：紧接着常量池的两个字节，这个标志用于识别一些类或者接口层次的访问信息，包括：这个Class是类还是接口、是否定义为public类型、是否定义为abstract类型、如果是类的话，是否被声明为final 类索引、父类索引与接口索引集合 类索引（this_class）：用于确定这个类或接口的全限定名，是对常量池中的类或接口的全限定名的索引值 父类索引（super_class）：用于确定这个类的父类的全限定名，也是对常量池 中某个类名的索引值 接口索引集合 接口计数器（interfaces_count）：接口表的成员数 接口表（interfaces [ ]）：用于描述这个类实现了哪些接口，每个成员都是对常量池中某项接口名称的索引值，顺序与源代码给定的顺序一致，下标从0开始 字段表集合 字段计数器（fields_count）：字段表的成员数 字段表（fields [ ]）：用于描述这个类或接口中声明的类变量以及实例变量，但不包括从父类或父接口继承的变量，每个变量包括访问标志（access_flags）、名称索引（name_index）、描述符索引（descriptor_index）、属性表集合（attributes），下标从0开始 方法表集合 方法计数器（methods_count）：方法表的成员数 方法表（methods [ ]）：用于描述这个类或接口中定义的实例方法、类方法、实例初始化方法（）和类或接口初始化方法（），但不包括从父类或父接口继承的方法（重写除外），每个方法的结构与变量结构类似，下标从0开始 属性表集合 属性计数器（attributes_count）：属性表的成员数 属性表（attributes [ ]）：每个字段表、方法表都可以携带自己的属性表集合，以用于描述某些场景专有的信息，一部分属性如下： Code：方法表的属性，存储方法体中的代码 Exceptions：方法表的属性，列举出方法中可能抛出的受查异常（方法throws关键字后面列举的异常） LineNumberTable：Code属性的属性，用于描述Java源码行号与字节码行号之间的对应关系 LocalVariableTable：Code属性的属性，用于描述栈帧中局部变量表中的变量与Java源码中定义的变量之间的关系 SourceFile：类文件的属性，用于记录生成这个Class文件的源码文件名称 ConstantValue：字段表的属性，通知虚拟机自动为静态变量赋值 InnerClasses：类文件的属性，用于记录内部类与宿主类之间的关联 Deprecated：类、方法表、字段表的属性，用于表示某个类、字段或方法已经被程序作者定为不再推荐使用 Synthetic：类、方法表、字段表的属性，用于表示此字段或方法并不是由Java源码直接产生的，而是由编译器自行添加的 Signature：类、方法表、字段表的属性，用于记录泛型签名信息 BootstrapMethods：类文件的属性，用于保存invokedynamic指令引用的引导方法限定符 2. 虚拟机类加载机制(1) 虚拟机的类加载机制虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被虚拟机直接使用的Java类型。 (2) 类的生命周期 加载（Loading） 验证（Verification） 准备（Preparation） 解析（Resolution） 初始化（Initialization） 使用（Using） 卸载（Unloading） 其中验证、准备、解析3个部分统称为连接（Linking） 加载、验证、准备、初始化和卸载的顺序是确定的，类的加载过程必须按照这种顺序按部就班地开始（不是进行或完成，因为这些阶段通常都是互相交叉地混合式进行的），解析阶段则不一定，因为它在某些情况下可以在初始化阶段之后再开始，这是为了支持Java语言的运行时绑定。 (3) 类必须初始化的情况 遇到new、getstatic、putstatic或invokestatic这4条字节码指令时，如果类没有进行过初始化，则需要先触发其初始化。生成这4条指令的最常见的Java代码场景是： 使用new关键字实例化对象的时候 读取或设置一个类的静态属性的时候（被final修饰、已在编译器把结果放入常量池的静态属性除外） 调用一个类的静态方法的时候 使用java.lang.reflect包的方法对类进行反射调用的时候，如果类没有进行过初始化，则需要先触发其初始化 当初始化一个类的时候，如果发现其父类还没有进行过初始化，则需要先触发其父类的初始化 当虚拟机启动时，用户需要指定一个要执行的主类（包含main()方法的那个类），虚拟机会先初始化这个主类 当使用JDK 1.7的动态语言支持时，如果一个java.lang.invoke.MethodHandle实例最后的解析结果为REF_getStatic、REF_putStatic、REF_invokeStatic的方向句柄，并且这个方法句柄所对应的类没有进行过初始化，则需要先触发其初始化 (4) 类加载的过程 加载（Loading）完成以下3件事情： 通过一个类的全限定名来获取定义此类的二进制字节流 将这个字节流所代表的静态存储结构转化为方法区的运行时数据结构 在内存中生成一个代表这个类的java.lang.Class对象，作为方法区这个类的各种数据的访问入口 验证（Verification） 目的是为了确保Class文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全 如果验证到输入的字节流不符合Class文件格式的约束（静态和结构化约束），虚拟机会抛出java.lang.VerifyError异常或其子类异常 验证主要包括以下几个阶段： 文件格式验证：验证字节流是否符合Class文件格式的规范，保证输入的字节流能正确地解析并存储于方法区之内 元数据验证：对类的元数据信息进行语义分析，以保证其描述的信息符合Java语言规范的要求 字节码验证：通过数据流和控制流分析，确定程序语义是合法的、符合逻辑的，主要对类的方法体进行校验分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的事件 符号引用验证：该阶段发生在虚拟机将符号引用转化为直接引用的时候，转化动作在解析阶段发生，该阶段是对类自身以外（常量池中的各种符号引用）的信息进行匹配性校验，确保解析动作能正常执行 准备（Preparation） 为类的静态字段分配内存并用默认值初始化这些字段 如果静态字段是常量，则会直接初始化会常量的值 解析（Resolution） 虚拟机将常量池内的符号引用替换为直接引用的过程 符号引用：以一组符号来描述所引用的目标，符号可以是任何形式的字面量，与虚拟机实现的内存布局无关 直接引用：可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄，和虚拟机实现的内存布局相关 解析的不同种类：类或接口解析、字段解析、类方法解析、接口方法解析、方法类型解析、方法句柄解析、调用点限定符解析 初始化（Initialization） 该阶段是按照程序制定的主观计划去初始化类变量和其他资源。也即执行类构造器()方法的过程 ()方法是由编译器自动收集类中的所有类变量的赋值动作和静态语句块（static{}）中的语句合并产生的，编译器收集的顺序是由语句在源文件中出现的顺序所决定的，静态语句块只能访问到定义在静态语句块之前的变量，定义在它之后的变量，只能赋值，不可以访问 ()方法与类的构造函数（或者说实例构造器()方法）不同，它不需要显示地调用父类构造器，虚拟机会保证在子类的()方法执行之前，父类的()方法已经执行完毕。因此在虚拟机中第一个执行的()方法的类肯定是Object类 由于父类的()方法先执行，因此父类中定义的静态语句块要优先于子类的静态语句块 ()方法对一个类来说不是必需的，如果一个类中没有静态语句块，也没有对变量的赋值操作，则不会生成()方法 接口中不能使用静态语句块，但仍然有变量赋值的操作，因此接口也会有()方法，但是与类不同的是，执行接口的()方法不需要先执行父接口的()方法。只有当父接口中定义的变量使用时，父接口才会初始化。另外，接口的实现类在初始化时也不会执行接口的()方法 虚拟机会保证一个类的()方法在多线程环境中被正确地加锁、同步，如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的()方法，其他线程都需要阻塞等待 (5) 类加载器 类加载器的含义 虚拟机把类加载阶段中的“通过一个类的全限定名来获取定义此类的二进制字节流”这个动作放到Java虚拟机外部去实现，以便让应用程序自己决定如何去获取所需要的类，实现这个动作的代码块称为“类加载器”。 对于任意一个类，都需要由加载它的类加载器和这个类本身一同确立其在Java虚拟机中的唯一性，因为每一个类加载器，都拥有一个独立的类名称空间。换句话说，比较两个类是否“相等”，只有在两个类是由同一个类加载器加载的前提下才有意义，否则，即使两个类来源于同一个Class文件，被同一个虚拟机加载，只要加载它们的类加载器不同，那这两个类就必定不相等。相等的含义包括类的Class对象的equals()方法、isAssignableFrom()方法、isInstance()方法的返回结果，也包括使用instanceof关键字对对象所属关系的判定 类加载器的分类 启动类加载器（Bootstrap ClassLoader） 使用C++语言实现，是虚拟机自身的一部分 负责加载存放在\lib目录中或者被参数-Xbootclasspath参数指定的路径中的被虚拟机识别的类库 该加载器无法被Java程序直接引用，用户在编写自定义类加载器时，如果需要把加载请求委派给该加载器，直接使用null替代即可 扩展类加载器（Extension ClassLoader） 使用Java语言实现，独立于虚拟机外部，由ExtClassLoader继承自抽象类java.lang.ClassLoader 负责加载存档在\lib\ext目录中或者被java.ext.dirs系统变量所指定的路径中的所有类库 开发者可以直接使用扩展类加载器 应用程序类加载器（Application ClassLoader） 使用Java语言实现，独立于虚拟机外部，由AppClassLoader继承自抽象类java.lang.ClassLoader 负责加载用户类路径（ClassPath）上所指定的类库 开发者可以直接使用应用程序类加载器，一般情况下这是应用程序的默认类加载器 类加载器的层次关系模型——双亲委派模型 要求：除了顶层的启动类加载器以外，其余的类加载器都应当有自己的父类加载器，这里加载器的父类关系一般不以继承的关系来实现，而是使用组合关系来复用父加载器的代码 工作过程：如果一个类加载器收到了类加载的请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成，每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类的加载器反馈自己无法完成这个加载请求时（它的搜索范围中没有找到所需的类），子加载器才会尝试自己去加载 好处：Java类随着它的类加载器一起具备了一种带有优先级的层次关系，如Object类，无论哪一个类加载器要加载这个类，最终都是委派给启动类加载器加载，因此Object类在程序的各种类加载器环境中都是同一个类 实现方法：先检查请求的类是否已经被加载，若没有加载，则调用父加载器的loadClass()方法，若父类加载器为空，则默认使用启动类加载器作为父类加载器，如果父类加载器加载失败，则先抛出ClassNotFoundException异常，然后再调用自己的findClass()方法进行加载 3. 虚拟机执行引擎(1) 虚拟机执行引擎 从外观上看，所有Java虚拟机的执行引擎都是一致的：输入的是字节码文件，处理过程是字节码解析的等效过程，输出的是执行结果。 在不同虚拟机的实现里面，执行引擎在执行Java代码时会有解释执行（通过解释器执行）和编译执行（通过即时编译器产生本地代码执行）两种选择。(2) 虚拟机进行方法调用和方法执行的数据结构——栈帧 具体介绍见“自动内存管理机制”中的“栈帧机构”(3) 虚拟机中的方法调用 方法调用的含义 该阶段的任务是确定被调用方法的版本（即调用哪一个方法），暂时还不涉及方法内部的具体运行过程 一切方法调用在Class文件里面（常量池）存储的都只是符号引用，而不是方法在实际运行时内存布局中的入口地址（直接引用） 在调用的不同层次上，包括解析和分派两种方式，两者不是二选一的排他关系 方法调用字节码指令 invokestatic：调用静态方法 invokespecial：调用实例构造器方法()、私有方法和父类方法 invokevirtual：调用所有的虚方法 invokeinterface：调用接口方法，会在运行时再确定一个实现此接口的对象 invokedynamic：先在运行时动态解析出调用点限定符所引用的方法，然后再执行该方法，前4条指令，分配逻辑固化在虚拟机内部，该条指令的分配逻辑由用户所设定的引导方法决定 解析调用 是个静态的过程，在编译期间就完全确定，在类装载的解析阶段就会把涉及的符号引用全部转变为可确定的直接引用 适合该类调用方法的特点：方法在程序真正运行之前就有一个可确定的调用版本，并且这个方法的调用版本在运行期是不可改变的，具体的方法如下，这些方法可以称为“非虚方法”（final方法也是非虚方法，但它使用invokevirtual指令进行调用）： 静态方法 私有方法 实例构造器 父类方法 分派调用 是Java语言多态特性的体现 根据静动态可以分为静态分派和动态分派，根据宗量数可以分为单分派和多分派 静态分派：所有依赖静态类型来定位方法执行版本的分派动作，典型应用是方法重载，发生在编译阶段 动态分派 根据实际类型确定方法执行版本的分派过程，应用于方法重写，发生在运行期间 实现方式：为类在方法区中建立一个虚方法表（相对应的有接口方法表），虚方法表中存放着各个方法的实际入口地址。如果某个方法在子类中没有被重写，那么子类的虚方法表里的地址入口与父类相同方法的地址入口是一致的，都指向父类的实现入口；如果子类中重写了这个方法，子类方法表中的地址将会替换为指向子类实现版本的入口地址 单分派与多分派 方法的接收者（执行方法的对象）与方法的参数统称为方法的宗量 根据一个宗量对目标方法进行选择称为单分派 根据多个宗量对目标方法进行选择称为多分派 在Java语言中，静态分派属于多分派，动态分派属于单分派(4) 虚拟机中的方法执行（其中一种：解释执行） 解释执行 图中间的那条分支就是解释执行的过程 Java语言中，Javac编译器完成了程序源码经过词法分析、语法分析到抽象语法树，再遍历语法树生成线性的字节码指令流的过程，这一部分动作在Java虚拟机之外进行，而解释器在虚拟机的内部，因此Java程序的编译是半独立的。 基于栈的指令集和基于寄存器的指令集 基于栈的指令集 Java编译器输出的指令流，指令流中的指令大部分都是零地址指令，依赖操作数栈进行工作 优点 可移植：不受硬件约束 代码相对更加紧凑：每个字节对应一条指令 编译器实现更加简单：不需要考虑空间分配问题，所需空间都在栈上操作 缺点：执行速度相对慢一些：完成相同功能所需指令数量更多，且需要频繁的内存访问 基于寄存器的指令集 主流PC机中直接支持的指令集架构，这些指令依赖寄存器工作 优点：利用了寄存器，执行速度会更快 缺点 移植困难：受硬件条件约束 编译器实现相对复杂，需要考虑寄存器的分配问题 基于栈的解释器执行过程 整个运算过程的中间变量都以操作数栈的出栈、入栈为信息交换途径]]></content>
      <categories>
        <category>java</category>
      </categories>
      <tags>
        <tag>内存管理</tag>
        <tag>垃圾收集</tag>
        <tag>类加载</tag>
      </tags>
  </entry>
</search>
